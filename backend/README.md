# Тестовая реализация авторизации
## Структура и назначение
В папке **/model** хранятся DTO:
- `AuthRequest` для запроса (логин пароль).
- `AuthResponse` для ответа (токен).
- `UserInfo` для данных пользователя (имя пользователя).

В папке **/security** немного всё намешано:
- `JwtService` для создания и валидации JWT. Токен генерируется на 24 часа.
- `JwtFilter` достаёт токен из тела запроса, валидирует и подставляет пользователя.
- `InMemoryUserService` для хранения пользователей (имитации БД), чтобы проверить регистрацию.
- `SecurityConfig` для настройки Spring Security (защита + фильтр).

В папке **/controller**:
- `AuthController` для эндпоинтов.
- `GlobalExceptionHandler` для обработки ошибок.

## Запуск приложения

### Автоматизированный скрипт (рекомендуется)
В файле `/backend/.env` указываем переменные окружения (см. `.env.example`).

Для удобства создан скрипт `dev-setup.sh`, который может выполнять различные этапы подготовки и запуска приложения:

```bash
# На Windows команды можно выполнить через Git Bash
# Запуск только приложения (по умолчанию)
./dev-setup.sh

# Выполнить миграции (база данных будет удалена и создана заново) и запустить приложение
./dev-setup.sh -m

# Сгенерировать Jooq классы и запустить приложение
./dev-setup.sh -g

# Собрать приложение и запустить
./dev-setup.sh -b

# Полный цикл: миграции + генерация + сборка + запуск
./dev-setup.sh -m -g -b
# или короче:
./dev-setup.sh -mgb

# Подготовка БЕЗ запуска приложения
./dev-setup.sh -mgbS    # Полный цикл без запуска
./dev-setup.sh -mS      # Только миграции без запуска
./dev-setup.sh -gS      # Только генерация без запуска

# Показать справку
./dev-setup.sh -h
```

**Доступные флаги:**
- `-m` — выполнить миграции базы данных
- `-g` — сгенерировать классы Jooq
- `-b` — собрать приложение
- `-S` — не запускать приложение (только выполнить указанные операции)
- `-h` — показать справку

## Проверка эндпоинтов
- **Регистрация:**
```pwsh
curl -i -X POST http://localhost:3000/auth/register -H "Content-Type: application/json" -d '{"login":"vlad", "password":"1234", "name":"Владислав Гаар"}' -c cookies.txt
```
Регистрирует пользователя. JWT-токен будет отправлен в Set-Cookie и сохранён в cookies.txt.

- **Логин:**
```pwsh
curl -i -X POST http://localhost:3000/auth/login -H "Content-Type: application/json" -d '{"login":"vlad", "password":"1234"}' -c cookies.txt
```
Логинится с уже зарегистрированным пользователем. JWT тоже сохранится в cookies.txt.

- **Эндпоинт /me:**
```pwsh
curl -X GET http://localhost:3000/me -b cookies.txt
```
Отправляет токен из куки. Возвращает информацию о текущем пользователе. Если куки нет или токен истёк — будет 401 ошибка.

## Логирование

Проект использует связку **Logback + Logstash + Elasticsearch + Kibana** для сбора и анализа логов.

Все логи приложения пишутся в `logs/app-log.json` в формате JSON, затем передаются в Logstash, который парсит их и отправляет в Elasticsearch.

---

### Конфигурация

- `src/main/resources/logback-spring.xml` - настройка Logback, формат логов, путь до файла.
- `logstash/logstash.conf` - настройка Logstash: откуда читать логи и как отправлять в Elasticsearch.
- `docker-compose.yml` - сервисы `logstash`, `elasticsearch` и `kibana`.

---

### Добавление логов в kibana

1. После запуска контейнеров переходим в kibana по адресу `http://localhost:5601/`. 

2. В сайдбаре слева переходим по пути `Management/Stack Management/Kibana/Data Views`.

3. Жмём `Create data view` и создаём новое представление с маской `spring-logs-*`. В поле `Timestamp field` указываем `@timestamp`. Сохраняем

4. Теперь в сайдбаре можем перейти в `Analytics/Discover`, выбрать наш Data view и просматривать JSON-логи с фильтрацией, поиском и таймфреймом.
